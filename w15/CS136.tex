\documentclass[english, 12pt]{article}
\usepackage{yingconfig}

% ========================Variables======================================
\newcommand{\coursecode}{CS 136}
\newcommand{\coursename}{.rkt in C}
\newcommand{\thisprof}{Professor M. Petrick}
\newcommand{\curterm}{Winter 2014}

\begin{document}
\notesheader

\section{Modularization}
\begin{defn}
A \textbf{module} is a collection of functions that share a common aspect or purpose. \textbf{Modularization} is dividing programs into modules.
\begin{itemize}
\item Reusability
\item Maintainability
\item Abstraction
\end{itemize}
\end{defn}
\begin{defn}
\textbf{provide} is used in a module to specify the identifiers availabie in the module.
\end{defn}
fun.rkt
\begin{lstlisting}[language=Scheme]
(provide fun?) ;Allows use of function outside of program
(define lofn `(-3 7 42 136 1337 4010 8675309))
;; (fun? n) determines if n is a fun integer
;; fun?: Int -> Bool
(define (fun? n)
  (not (false? (member n lofn))))
\end{lstlisting}
\begin{defn}
\textbf{require} is used to identify a module that the current program depends on.
\end{defn}
implementation.rkt
\begin{lstlisting}[language=Scheme]
(require "fun.rkt")
;;Able to use provided functions in required file
(fun? 7) ; => #t
(fun? -7) ; => #f
\end{lstlisting}
\subsection{Scope}
\begin{itemize}
\item \textbf{Local:} Visible only in local region
\item \textbf{Module:} Only visible in the module it is defined in
\item \textbf{Program:} Visible outside the module.
\end{itemize}
\begin{qte}
\textbf{require} also outputs the final value of any of the top-level expressions in the module. Only definitions should be included in modules.
\end{qte}
\begin{defn}
A module \textbf{interface} is the list of functions that a module provides. Documentation should be provided.
\begin{itemize}
\item Description of module
\item List of functions provided
\item Contract and purpose for each provided function
\end{itemize}
\end{defn}
\begin{defn}
The \textbf{implementation} is the code for the module.
\begin{itemize}
\item Hides implementation details from client
\item Security
\item Flexibility to modify implementation
\end{itemize}
\end{defn}

\begin{defn}
\textbf{High cohesion} means that all interface functions are related.
\end{defn}
\begin{defn}
\textbf{Low coupling} means that there is little interaction between modules.
\end{defn}

\begin{qte}
Always truncate decimals
\end{qte}


\begin{lstlisting}[language=C]
int main (void) {
  printf(``Hello World! \n'')
}
\end{lstlisting}
\begin{defn}
\%d is used as a placeholder to the values that follow.
\begin{lstlisting}[language=C]
printf("%d plus %d is: %d\n", 1 + 1, 2, 2 + 2);
\end{lstlisting}
In racket, ~a is used as a placeholder.
\begin{lstlisting}[language=Scheme]
(printf ``There are ~a lights!\n'' ``four'')
(printf ``There are ~a lights!\n'' 'four) ; Both lines are same
\end{lstlisting}
\end{defn}

\begin{defn}
Structures in C are very similar to racket.
\begin{lstlisting}[language=C]
struct posn {
  int x;
  int y;
}; //Do not forget the semicolon

const struct posn p = {3,4}; // Initialization
const struct posn pp = {y=4,x=3}; // This works too
const struct posn pp = {x=3}; // Uninitialized integers are set to 0.

const int a = p.x;
const int b = p.y;
\end{lstlisting}
\end{defn}


\begin{defn}
\textbf{begin} produces the value of the last exprssion
\begin{lstlisting}[language=Scheme]
(define (mystery)
  (begin ; implicit, this line not needed
    (+ 1 2) ; evaluated, not used
    (+ 2 2))) ;outputs 4
\end{lstlisting}
\end{defn}
\begin{qte}
Anything that is not \#f in Racket is true.
\end{qte}
\section{Imperative Programming}
\begin{defn}
The \textbf{functional programming paradigm} is to only use constant values that never change. Functions produce new values rather than changing existing ones. In functional programming, there are no side effects.
\end{defn}

\begin{defn}
A \textbf{side effect} does more than produce a value it also changes the state of the program. Sometimes used to debug.
\end{defn}

\begin{defn}
In an expression statement, the \textbf{value} of the expression is \textbf{ignored}.
\begin{lstlisting}[language=C]
3 + 4;
\end{lstlisting}
\end{defn}

\begin{defn}
A \textbf{block} $\{\}$, is known as a compound statement, and contains a sequence of statements.  Within a block, \textbf{local scope definitons} can also be included.
\end{defn}

\begin{defn}
\textbf{printf} in C returns an int representing the number of characters printed.
\end{defn}

\begin{defn}
\textbf{Control flow statements} change the flow of a program and the order in which other statements are executed.
\begin{itemize}
\item \textbf{return} statement ends the execution of a function and returns a value.
\item \textbf{if} and \textbf{else} statements execute statements conditionally
\end{itemize}
\end{defn}
\begin{qte}
The defining characteristic of \textbf{imperative programming paradigm} is to \textbf{manipulate state}.
\end{qte}

\begin{defn}
\textbf{State} refers to the value of a data at a moment in time.
\end{defn}

\begin{defn}
When the value of a variable is changed, it is called \textbf{mutation}.
\begin{lstlisting}[language=C]
int x = 5;
struct posn p = {3,4};
\end{lstlisting}
\end{defn}
\begin{defn}
\textbf{Prefix} and \textbf{postfix} increment operator:
\begin{lstlisting}[language=C]
x++ // Produces old value, and increments as side effect
++x // Increments x and then produces the value
\end{lstlisting}
\end{defn}

\section{C Model}

\begin{defn}
A \textbf{bit} has two states: $0$ or $1$. A \textbf{byte} is $8$ bits of storage. Each byte is in one of $256$ possible states.
\end{defn}


\begin{defn}
\textbf{Memory addresses} are represented in hex (prefixed with $0x$), so a typical address would be $0xFFFFF$.
\end{defn}

\begin{defn}
\textbf{sizeof} produces the amount of space (bytes) a variable uses.
\begin{itemize}
\item A \textbf{char} is $1$ byte.
\item An \textbf{int} is $4$ bytes.
\item An \textbf{address} is $8$ bytes.
\end{itemize}
\end{defn}

\begin{note}
When a variable is initialized, three steps occur:
\begin{itemize}
\item Reserves space in memory to store the variable
\item Records the address to the location
\item Store the value of the variable at the address.
\end{itemize}
\begin{center}
\begin{lstlisting}[language=C]
int n = 4;
\end{lstlisting}
\begin{tabular}{|c|c|c|c|}
\hline
identifier & type & bytes & address \\
\hline
$n$ & int & $4$ & $0x5000$ \\
\hline
\end{tabular}
\end{center}
\end{note}
\begin{qte}
A variable definition reserves space, but declaration does not.
\end{qte}

\begin{note}
If an int is larger than the maximum $2^31 - 1$ or smaller than the minimum $- 2^31$, overflow will occur. Remember to always try and avoid chance of overflow wherever possible.
\end{note}

\begin{note}
For characters, A is $65$, $a$ is 97, space is $32$, $0$ is $48$, and newline is $10$ in ASCII.
\end{note}

\begin{note}
The \text{sizeof} a structure is at least the sum of the size of each field.
\end{note}


\begin{defn}
A \textbf{float} represents real numbers and has a larger range than int. Floats are very imprecise, and doubles are usually used instead.
\end{defn}


\subsection{Memory}
Memory can be modelled as
\begin{center}
\begin{tabular}{|c|}
\hline
Code \\
\hline
Read-Only Data \\
\hline
Global Data \\
\hline
Heap \\
\hline
Stack \\
\hline
\end{tabular}
\end{center}
\begin{defn}
Converting source code to machine code is known as \textbf{compiling}
\end{defn}

\begin{note}
Global constants are stored in read-only, and global variables are stored in global data. The space is reserved before execution.
\end{note}

\begin{defn}
\textbf{control flow} is used to model how programs are executed.
\end{defn}

\begin{defn}
The history of what a program needs to do is called the \textbf{call stack}. When a function is called, it is pushed onto the call stack. When a return is used, an entry is popped off the stack.
\end{defn}

\begin{defn}
An entry pushed onto a call stack is a \textbf{stack frame}. A stack frame consists of
\begin{itemize}
\item Argument values
\item Local variables
\item Return address
\end{itemize}
\end{defn}
\begin{qte}
When the function returns, the entire stack frame is destroyed along with its local variables.
\end{qte}

\begin{defn}
When the stack frame is too large, it can collide with other sections of memory. This is called \textbf{stack overflow}.
\end{defn}

\begin{qte}
All global variables that are uninitialized are automatically initialized to 0. Uninitiaized local variables have an arbitrary initial value.
\end{qte}

\subsection{Loops}
\begin{defn}
\textbf{while} reeatedly loops back and executes the statement until the expression is false.
\end{defn}

\begin{defn}
The \textbf{do} statement is similar to the while statement but evaluates the expression after execution. Because of this, the loop is always executed at least once.
\end{defn}

\begin{defn}
\textbf{break} is used to break out of a loop.
\end{defn}

\begin{defn}
\textbf{continue} skips the current block of execution and continues the loop.
\end{defn}

\begin{lstlisting}[language=C]
int num = 6;
while (num!=0) { // 6,3,2,1, end
  if (num == 6) {
    num -= 3;
    continue;
  }
  num --;
}
\end{lstlisting}

\begin{defn}
\textbf{for} is similar to a condensed form of a while loop.
\begin{lstlisting}[language=C]
for (int i = 0 ; i < 5; i++) { body }
\end{lstlisting}
Any component may be omitted in a for loop. An omitted expression is always true. Commas may be used for compound statements in the setup of a for loop.
\end{defn}

\section{Pointers}

\begin{defn}
The \textbf{address operator} \& produces the starting address of where the value of an identifier is stored in memory.
\end{defn}

\begin{defn}
By adding a * before an identifier, it becomes a pointer, and its value is an address.
\begin{lstlisting}[language=C]
i = 42;
int *p = &i; // p points to i
printf(``p is %p'', p); \\ prints the address of i
\end{lstlisting}
\end{defn}

\begin{defn}
The \textbf{indirection operator} * is the inverse of address operator and produces the value of what a pointer points at.
\begin{lstlisting}[language=C]
int = 42;
int *p = &i; //points at address of i
int j = *p // 42
\end{lstlisting}
\end{defn}
\begin{note}
C mostly ignores whitespace, so the following lines are all equivalent.
\begin{lstlisting}[language=C]
int *pi = &i; // style A (preferred)
int * pi = &i; // style B
int* pi = &i; // style C
\end{lstlisting}
\end{note}

\begin{defn}
By adding multiple asterisks, a pointer to a pointer may be declared.
\begin{lstlisting}[language=C]
int i = 42;
int *pi = &i; // address of i
int **ppi = &pi; // address of pi
\end{lstlisting}
\end{defn}

\begin{defn}
\textbf{NULL} is a pointer value that represents that the pointer points to nothing.
\end{defn}

\subsection{Pointer Assignment}
The value of what a pointer is pointing at may be changed. They can be dereferenced to change the value of the variable they point at without actually using the variable.
\begin{lstlisting}[language=C]
int i = 5;
int j = 6;
int *p = &i;
int *q = p;
*q = j; // i = 6
\end{lstlisting}

\begin{note}
Pointers may be used to emulate \textbf{pass by reference} even though C is pass by value.


\begin{lstlisting}[language=C]
void inc(int *p) {
  *p += 1;
}

int main(void) {
  int x = 5;
  inc(&x); // note the &
  printf("x = %d\n", x); // NOW it's 6
}
\end{lstlisting}
This may also be used on structures, but brackets must be added around the dereference \textbf{(*p).x}
\end{note}

\begin{defn}
The \textbf{arrow selection operator} (->) combines the indirection and selection operators. This may only be used with a pointer to a structure.
\begin{lstlisting}[language=C]
int sqr_dist (struct posn *p1, struct posn *p2) {
  const int xdist = p1->x - p2->x;
  const int ydist = p1->y - p2->y;
  return xdist * xdist + ydist * ydist;
}
\end{lstlisting}
\begin{note}
These parameters may also be mutated.
\end{note}
\end{defn}

\section{I/O \& Testing}

\begin{defn}
\textbf{fprintf} has an addition parameter that points to a file. It is similar to printf but prints directly to the file.
\begin{lstlisting}[language=C]
int main(void) {
  FILE * file_ptr;
  file_ptr = fopen("hello.txt","w");   // w for write
  fprintf(file_ptr, "Hello World!\n");
  fclose(file_ptr);
}
\end{lstlisting}
\end{defn}

\begin{defn}
In Racket, \textbf{(read)} is used to get a value from keyboard.
\begin{lstlisting}[language=Scheme]
(define key-inp (read))
\end{lstlisting}
Text is interpreted as symbols unless it is surrounded with double quotes.
\end{defn}

\begin{defn}
In C, \textbf{scanf} is used for keyboard input. scanf returns the number of values successfully read. If there is an error, 0 is returned by scanf.
\begin{lstlisting}[language=C]
int count = scanf(``%d'', &i); // Reads integer, and stores it in i. Count should be 1.
\end{lstlisting}
\end{defn}
\begin{note}
When reading in characters, it may be beneficial to ignore whitespace.
\begin{lstlisting}[language=C]
int count = scanf(``%c'', &c); // May read whitespace
int count2 = scanf (`` %c'', &c); // Skips whitespace
\end{lstlisting}
\end{note}

\section{Arrays and Strings}

\begin{lstlisting}[language=C]
int a[5]; // Valid, size defined
int b[] = {4,8,15,16,23,42}; //Valid size can be computed
int c[]; // Invalid
\end{lstlisting}

\begin{defn}
The \textbf{length} if an array is the number of elements in the array.
\end{defn}

\begin{defn}
The \textbf{size of an array} is the number of bytes it occupies in memory.
\end{defn}

\begin{qte}
C does not explicitly keep track of the array length.
\end{qte}

\begin{lstlisting}[language=C]
int a[] = {2,4}; // a by default points to a[0]
assert(&a == &a[0]);
assert(a == &a);
assert(*a == a[0])
\end{lstlisting}

\begin{note}
An array cannot be mutated. Only its elements can change.
\begin{lstlisting}[language=C]
int a[3] = {0, 0, 0};
int b[3] = {1, 2, 3};
a = b; // INVALID
\end{lstlisting}
\end{note}

\begin{qte}
When passing an array to a function, typically the length of the array is unknown and must be provided as a separate parameter.
\end{qte}

\begin{qte}
In an array, pointers can be subtracted. However, pointer arithmetic is only valid within an array.
\end{qte}

\begin{note}
If there are two pointers $p$ and $q$,
\[p-q = \f{(p-q)}{sizeof(*p)}\]
\[p + i = p + i \times sizeof(*p)\]
$p\lbrack i \rbrack $ is equivalent to $*(p + i)$.
\end{note}

\begin{exmp}
In \textbf{array pointer notation} square brackets are not used, and all array elements are accessed through pointer arithmetic.

\begin{lstlisting}[language=C]
// Pointer notation
int sum_array(const int *a, int len) {
  int sum = 0;
  for (const int *p = a; p < a + len; ++p) {
    sum+=*p;
  }
  return sum;
}

// Square bracket notation
int sum_array(const int a[], int len) {
  int sum = 0;
  for (int i = 0; i < len; ++i) {
    sum+=a[i];
  }
  return sum;
}
\end{lstlisting}
\end{exmp}

\begin{defn}
\textbf{Multi-dimensional data} can be represented by mapping the higher dimensions down to one. That is, to select an element at a specific row and column, you would do $\text{data}\lbrack row \& NUMCOLS + col \rbrack$.
\end{defn}

\begin{defn}
\textbf{Function pointers} store the starting address of a function within the code section. A function pointer in C can only point to a function that already exists.
\begin{lstlisting}[language=C]
int add1(int i) {
  return i + 1;
}

int (*fp)(int) = add1;
// Return value first, then name of function, then its parameters
// Now you can call the function with fp(int i)

// Another is to use it as a parameter
// The below function adds 70 to a number, n
int doSomething(int (*fcn)(int), int n) {
  return fcn(n) + 69;
}
\end{lstlisting}
\end{defn}

\begin{note}
These function pointers are useful for abstract list functions seen in Racket.
\begin{lstlisting}[language=C]
void array_map(int (*f)(int), int a[], int len) {
  for (int i = 0; i < len; ++i) {
    a[i] = f(a[i]);
  }
}
\end{lstlisting}
\end{note}
\subsection{Strings}
\begin{defn}
A \textbf{string} in C is just an array of characters terminated by a null character `\\0'. If a string is initialized as an array, the null terminator is necessary, but if it is initialized with double quotes, then the null terminator is automatically added.
\begin{lstlisting}[language=C]
char a[] = {'c','a','t','\0'};
char b[] = ``cat'' // Equivalent
\end{lstlisting}
\end{defn}

\begin{defn}
C strings used in statements (eg with printf) are known as \textbf{string literals}. For these statements, a null terminated const char array is created in the \textbf{read-only data section}.
\end{defn}

\begin{defn}
The \textbf{strlen} function returns the length of the string, NOT THE LENGTH OF THE ARRAY. It also does not include the null character. It is found in the <string.h> library.
\end{defn}

\begin{defn}
Strings are compared by their \textbf{lexicographical order}. That is, for each character, sort by the ASCII values of the characters. If the end of one string is encountered, it precedes teh other string. The \textbf{strcmp(s1,s2)} function returns 0 if the strings are identical, -1 if s1 < s2, and 1 if s1 > s2.
\end{defn}

\begin{note}
Do not compare strings directly (eg: s1 == s2). This only compares pointers, not the actual content!.
\end{note}

\begin{qte}
When allocating space for a string, DO NOT FORGET THE NULL CHARACTER.
\end{qte}

\begin{defn}
\textbf{strcpy(char * dest, const char *src)} copies the content of the string src to dest. \textbf{strcat(char * dest, const char *src)} appends the content of src to dest. Make sure that array is large enough so the content may be copied without \textbf{buffer overflow}.
\end{defn}

\section{Efficiency}

\begin{defn}
An \textbf{algorithm} is a step-by-step description of how to solve a problem.
\end{defn}

\begin{defn}
\textbf{Time efficiency} is how long an algorithm takes to solve a problem.
\end{defn}

\begin{defn}
\textbf{Space efficiency} is how much space/memory an algorithm requires to solve a problem.
\end{defn}

\begin{defn}
In this course, the running time of a function is a function of $n$, denoted $T(n)$. $n$ is usually the length of the input (array, number size, etc). They are usually measured in the worst case.
\end{defn}

\begin{defn}
\textbf{Big O Notation} showcases the \textbf{order} of a running time. That is, it is the dominant power as $n \to \infty$.
\end{defn}

\begin{exmp}
When adding two orders, the result is the largest of the two orders.\\
$O(log\,n) + O(n) = (n)$ and $O(1) + O(1) = O(1)$.
\end{exmp}

\begin{exmp}
When multiplying two orders, the result is the product of the two orders.\\
$O(log\,n) \times O(n) = O(n\,log\,n)$ and $O(1) \times O(n) = O(n)$.
\end{exmp}

\begin{defn}
\textbf{Simple functions} are functions without recursion or iteration. In C, all operations and O(1), so the running time of a simple function is
\[O(1) + \cdots + O(1) = O(1)\]
\end{defn}

\todo{Should include racket running times slide?}

\begin{defn}
For recursive functions, we analyze the \textbf{recurrence relation}. For now, use a table to determine the runtime.

\[T(n) = O(1) + T(n - k_1) = O(n)\]
\[T(n) = O(n) + T(n - k_1) = O(n^2)\]
\[T(n) = O(1) + T(\f{n}{k_2})\]
\[T(n) = O(1) + k_2 \cdot T(\f{n}{k_2})\]
\[T(n) = O(n) + k_2 \cdot T(\f{n}{k_2})\]
\[T(n) = O(1) + T(n-k_1) + T(n-k_1') = O(2^n)\]
An example of $2^n$ is the recursive fibonacci sequence.
\end{defn}

\begin{mthd}
\textbf{Procedure for recursive functions}:
\begin{enumerate}
\item Identify order of function excluding recursion
\item Determine size of input for next recursive calls
\item Write full recurrence relation, and look up in a table
\end{enumerate}
\end{mthd}

\begin{defn}
\textbf{Iterative analysis} utilizes \textbf{summations} instead of recurrence relations.
\begin{lstlisting}[language=C]
for (i = 1; i <=n; i++) {
  printf("*");
} //O(n) time
\end{lstlisting}
\[T(n) = \sum_{i=1}^n O(1) = \underbrace{O(1) + \cdots + O(1)}_n = n \times o(1) = O(n)\]
\end{defn}

\begin{note}
If a given list is of constant length (not dependant on input size), all operations are O(1).
\begin{lstlisting}[language=C]
for (int i = 0; i < 696969; i++) {
  sum+=a[i];
}
// O(1) linear time because a large number is still a constant.
\end{lstlisting}
\[\sum_{i=1}^{log\,n} O(1) = O(log\,n)\]
\[\sum_{i=1}^{n} O(1) = O(n)\]
\[\sum_{i=1}^{n} O(n) = O(n^2)\]
\[\sum_{i=1}^{n} O(i) = O(n^2)\]
\end{note}

\begin{mthd}
\textbf{Procedure for iteration}
\begin{enumerate}
\item Work from innermst loop to outermost
\item Determine number of iterations in the loop
\item Determine running time per iteration
\itm Write summation and simplify expression
\end{enumerate}
\end{mthd}

\begin{note}
When the loop counter changes geometrically, the number of lterations is often logarithmic.
\begin{lstlisting}[language=C]
while (n > 0) {
  // Do something
  n /= 10;
}
\end{lstlisting}
\end{note}

\begin{exmp}
\textbf{Sorting Algorithm:}
\begin{itemize}
\item Insertion Sort: O(n^2)
\item Selection Sort: O(n^2)
\item Merge Sort: O(n log n)
\item Quick Sort: O(n^2)
\end{itemize}
\end{exmp}

\begin{defn}
A function is \textbf{tail recursive} if the recursive call is alwasy the last expression to be evaluated. With tail recursion, the previous stack frame can be \textbf{reused} for the next recursion.
\end{defn}

\section{Dynamic Memory}

\begin{defn}
\textbf{Dynamic memory} is allocaetd from the \textbf{heap} while the programming is running.
\end{defn}

\todo{Dynamic Memory}
\section{Linked Data}

\begin{defn}
A \textbf{linked list node} usually contains an item and a link (pointer) to the next node.
\begin{lstlisting}[language=C]
struct llnode {
  int item;
  struct llnode * next;
}
\end{lstlisting}
\end{defn}

\end{document}
