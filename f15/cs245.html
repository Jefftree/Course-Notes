<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
</head>
<body>
<h1 id="cs-245">CS 245</h1>
<ul>
<li>Natural Language</li>
</ul>
<h2 id="propositional-logic">Propositional Logic</h2>
<p><strong>Logic</strong> is the systematic study of the principles of reasoning and inference. - Used for modeling computer hardware, software, and embedded systems. - Designing systems that can apply reason and inferences (artificial intelligence)</p>
<p>A <strong>proposition</strong> is a declarative sentence that is either <strong>true</strong> or <strong>false</strong>.</p>
<h2 id="english-to-propositional-logic">English to Propositional Logic</h2>
<p><span class="math inline">\(\lnot p\)</span>: not p, it is not the case of p</p>
<p><span class="math inline">\(p \land q\)</span>: p and q, p but q, not only p but q, p while q, p despite q, p yet q, p although q</p>
<p><span class="math inline">\(p \lor q\)</span>: p or q, p and/or q, p unless q</p>
<p><span class="math inline">\(p \implies q\)</span>: if p then q, q if p, p only if q, q when p, p is sufficient for q, q is necessary for p</p>
<p><span class="math inline">\(p \iff q\)</span>: p if and only if q, p is equivalent to q, p exactly if q, p is necessary and sufficient for q</p>
<p>A logic is formalized for syntax, semantics, and proof procedures.</p>
<h2 id="syntax">Syntax</h2>
<p>Atomic propositions are combined into compound propositions, and are analyzed as a set of interrelated propositions.</p>
<p><strong>Propositions</strong> are represented by formulas which contains a sequence of symbols. An <strong>expression</strong> is a finite sequence of symbols. - Propositional variables - Denoted with lowercase Roman letters - Connectives - Logic operators (NOT, AND, OR) - Punctuation - Brackets</p>
<p><strong>Binary</strong> connectives (AND, OR, IMPLIES) apply to two things. <strong>Unary</strong> connectives (NOT) are only applied to one.</p>
<p>A <strong>formula</strong> can be built from a set of proposition variables. A formula can be atom, negation, conjunction, disjunction, implication. It should only take on the type of the outermost type.</p>
<p><strong>Example</strong>: $(p q) r $ is an implication.</p>
<h2 id="semantics">Semantics</h2>
<p>The <strong>semantics</strong> of a logic describes how to interpret the well-formed formulas of the logic.</p>
<p>A <strong>truth valuation</strong> is a function with the set of all proposition symbols as domain and assigns a truth value (T,F) to each propositional variable.</p>
<p>For example <span class="math inline">\(t(p) = p^t = T\)</span></p>
<p>Everything can be built from the nand symbol. (see computer boolean)</p>
<p>To prove theorems, mathematical induction is used.</p>
<p><strong>Principle of Mathematical Induction:</strong></p>
<p>Establish that the base case has a property <span class="math inline">\(P\)</span>. Show that if the property holds for the base case, the next number also holds the property. Conclude that the property holds for all <span class="math inline">\(n \in N,n \geq BC\)</span></p>
<p><strong>Theorem</strong>: Let <span class="math inline">\(R\)</span> be a property, suppose that</p>
<ol style="list-style-type: decimal">
<li>for each atomic formula <span class="math inline">\(p\)</span>, we have <span class="math inline">\(R(p)\)</span></li>
<li>For each formula <span class="math inline">\(\alpha\)</span>, if <span class="math inline">\(R(\alpha)\)</span> then <span class="math inline">\(R((\lnot \alpha))\)</span></li>
<li>For each pair of formulas <span class="math inline">\(\alpha\)</span> and <span class="math inline">\(n\)</span>, and each connective <span class="math inline">\(*\)</span>, if <span class="math inline">\(R(\alpha)\)</span> and <span class="math inline">\(R(n)\)</span>, then <span class="math inline">\(R((\alpha * n))\)</span>.</li>
</ol>
<p>This is called <strong>structural induction</strong>.</p>
<h2 id="something-happened-here">Something happened here</h2>
<h2 id="working-with-formulas">Working with Formulas</h2>
<p>A formula <span class="math inline">\(\alpha\)</span> is a <strong>tautology</strong> if and only if for every truth valuation <span class="math inline">\(t\)</span>, <span class="math inline">\(\alpha^t = T\)</span></p>
<p>A formula <span class="math inline">\(\alpha\)</span> is a <strong>contradiction</strong> if and only if for every truth valuation <span class="math inline">\(t\)</span>, <span class="math inline">\(\alpha^t=F\)</span>. Example: <span class="math inline">\(p \land \lnot p\)</span></p>
<p>A formula <span class="math inline">\(\alpha\)</span> is <strong>satisfiable</strong> if and only if there is some truth valuation <span class="math inline">\(t\)</span>, such that <span class="math inline">\(\alpha^t=T\)</span></p>
<p><strong>Note:</strong> A formula is satisfiable if and only if it is not a contradiction.</p>
<p>A <strong>valuation tree</strong> is a shortcut to analyzing what would happen if the entire truth table was filled out.</p>
<p>Two formulas are <strong>equivalent</strong>, <span class="math inline">\(\alpha \equiv \beta\)</span> if <span class="math inline">\(\alpha^t = \beta^t\)</span> for every valuation <span class="math inline">\(t\)</span>.</p>
<p><strong>Lemma:</strong> Suppose that <span class="math inline">\(\alpha \equiv \beta\)</span>. Then for any formula <span class="math inline">\(\gamma\)</span>, and any connective <span class="math inline">\(*\)</span>, the formula <span class="math inline">\(\alpha * \gamma\)</span> and <span class="math inline">\(\beta * \gamma\)</span> are equivalent.</p>
<p><span class="math display">\[\alpha * \gamma \equiv \beta * \gamma*\]</span></p>
<p><strong>Example:</strong> Prove <span class="math inline">\((p \land q) \lor (q \land r) \equiv (q \land (p \lor r))\)</span></p>
<p><strong>Proof</strong>: <span class="math inline">\(= (p \land q) \lor (q \land r)\)</span></p>
<p><span class="math inline">\(= (q \land p) \lor (q \land r)\)</span></p>
<p><span class="math inline">\(= (q \land (p \lor r))\)</span></p>
<p><strong>Simplify</strong>: <span class="math inline">\(p \lor (p \land q)\)</span></p>
<p><strong>Solution:</strong></p>
<p><span class="math inline">\(= (p \land T) \lor (p \land q)\)</span></p>
<p><span class="math inline">\(= p \land (T \lor q)\)</span></p>
<p><span class="math inline">\(=p\)</span></p>
<h2 id="class">Class</h2>
<p>Prove <span class="math inline">\(\lnot(((\lnot p \lor q) \lor r) \land \lnot r \land p) \lor q\)</span></p>
<p><strong>Example:</strong> Prove or disprove <span class="math inline">\(p \equiv p \land (q \implies p)\)</span></p>
<p><span class="math inline">\(p \land (q \implies p)\)</span></p>
<p><span class="math inline">\(p \land (q \lor \lnot p)\)</span> Implication</p>
<p><span class="math inline">\(p \land (\lnot p \lor q)\)</span> Commutativity</p>
<p><span class="math inline">\(p\)</span> Simplification II</p>
<p>LHS=RHS</p>
<p><strong>Example:</strong> Prove or disprove <span class="math inline">\(p \land (\lnot (\lnot q \land \lnot p) \lor p) \equiv q\)</span></p>
<p><strong>Solution:</strong> Find an counter example. Select <span class="math inline">\(t(p) = F, t(q) = T\)</span>. LHS = F, RHS = T</p>
<p>Alternatively, simplify first if a value cannot be found by inspection.</p>
<p><span class="math inline">\(p \land ((q \lor p) \lor p)\)</span></p>
<p><span class="math inline">\(p \land (q \lor (p \lor p))\)</span></p>
<p><span class="math inline">\(p \land (q \lor p)\)</span></p>
<p><span class="math inline">\(p \land (p \lor q)\)</span></p>
<p><span class="math inline">\(p\)</span></p>
<h2 id="logical-consequence">Logical Consequence</h2>
<p>Let <span class="math inline">\(\sigma\)</span> be a set of formulas and let <span class="math inline">\(\phi\)</span> be a formula. We say that</p>
<ul>
<li><span class="math inline">\(\phi\)</span> is a logical consequence of <span class="math inline">\(\sigma\)</span> or</li>
<li><span class="math inline">\(\sigma\)</span> semantically entails <span class="math inline">\(\phi\)</span>, or</li>
<li>in symbols, <span class="math inline">\(\sigma |= \phi\)</span></li>
</ul>
<p>if and and only if for any truth value <span class="math inline">\(t\)</span></p>
<p><span class="math display">\[\sigma^t = T \implies\phi^t = T\]</span></p>
<p><strong>Example:</strong></p>
<p><span class="math display">\[\{(p \implies q),q\} |= q\]</span></p>
<p><strong>Solution:</strong> Whenever <span class="math inline">\(\{(p \implies q),q\}\)</span>, <span class="math inline">\(q\)</span> must be true. This can be shown from drawing a truth table.</p>
<p><strong>Example:</strong> <span class="math inline">\(\{p \implies q, q\} |\not= p\)</span></p>
<p><strong>Solution:</strong> When <span class="math inline">\(p = F,q = T\)</span>, and the proposition does not hold.</p>
<p><strong>Example:</strong> <span class="math display">\[\{(p \implies q), (q \implies r)\} |= (r \implies q)\]</span></p>
<p><strong>Solution:</strong> Draw huge truth table. <span class="math inline">\(p=F,q=F,r=T\)</span> has <span class="math inline">\(\sigma^t = T\)</span> and <span class="math inline">\(\phi^t = F\)</span></p>
<p><strong>Note:</strong> If <span class="math inline">\(\sigma\)</span> is a contradiction, <span class="math inline">\(\sigma |= \phi\)</span> will always be true.</p>
<h2 id="dealing-with-code">Dealing with Code</h2>
<p>If statement fragments can be simplified by drawing a truth table and taking the simplest expressions. The <strong>else</strong> block should be the largest block to avoid writing extra code.</p>
<h2 id="section"></h2>
<p>Formulas <span class="math inline">\(\alpha \implies \beta\)</span> and <span class="math inline">\(\lnot\alpha \lor \beta\)</span> are equivalent. Thus <span class="math inline">\(\impies\)</span> is said to be <strong>definable</strong> in terms of <span class="math inline">\(\lnot\)</span> and <span class="math inline">\(\lor\)</span>.</p>
<p>There are sixteen possible binary connectives. (16 because there are 16 way to permutate T and F over the truth table containing 4 slots. Two are nullary (ignores the value they connect), and four others are unary (ignore one value but not the other).</p>
<p>A set of connectives is <strong>adequate</strong> iff any <span class="math inline">\(n\)</span>-ary <span class="math inline">\((n\geq 1)\)</span> connective can be defined in terms of ones in the set.</p>
<p><span class="math inline">\((\lor,\land,\lnot)\)</span> is an adequate set of connectives.</p>
<p><span class="math inline">\((\land,\lnot)\)</span>,<span class="math inline">\((\lor,\lnot)\)</span>,<span class="math inline">\((\implies,\lnot)\)</span> are adequate sets of connectives.</p>
<h2 id="section-1">Section</h2>
<p>A <strong>proof</strong> is a formal demonstration that a statement is true. I</p>
<ul>
<li>It must be mechanically checkable. Intuition and insight should not be necessary.</li>
<li>Any computer could verify its correctness</li>
</ul>
<p>A proof is generally syntactic, rather than semantic. Permits mechanical checking. Rules chosen for semantic reasons.</p>
<p>A proof consists of a list of formulas. Assumption <span class="math inline">\(\rightarrow\)</span> inference <span class="math inline">\(\rightarrow\)</span> inference rules $$ conclusion.</p>
<p>A set of inference rules defines a <strong>proof system</strong>.</p>
<p>We notate &quot;there is a proof with assumptions <span class="math inline">\(\sum\)</span> and conclusion <span class="math inline">\(\phi\)</span>&quot; by <span class="math inline">\(\sum \vdash \phi\)</span></p>
<p>An inference rule is written as</p>
<p><span class="math display">\[\frac{a_1\qquad a_2 \cdots a_i}{\beta}\]</span></p>
<p>This means, suppose each formula in <span class="math inline">\(\alpha\)</span> already appears in the proof (either assumed or previously inferred), then one may infer the formula <span class="math inline">\(\beta\)</span></p>
<p>Example <span class="math inline">\(\frac{\alpha \, \beta}{\alpha \land \beta}\)</span></p>
<h2 id="approaches-to-proofs">Approaches to Proofs</h2>
<p>Direct proof. Establish <span class="math inline">\(\sum \vDash \phi\)</span>. Give a proof with <span class="math inline">\(\alpha_1,\alpha_2,\dots,\alpha_n\)</span> as assumptions and obtain <span class="math inline">\(\phi\)</span> as conclusion.</p>
<p>Refutations (indirect proofs, proof by contradiction)</p>
<p>Establish <span class="math inline">\(\sum \vDash \phi\)</span>. Assume <span class="math inline">\(\lnot \phi\)</span> and <span class="math inline">\(\alpha_1,\alpha_2,\dots,\alpha_n\)</span> and obtain a contradiction as conclusion. This works because any valuation that makes <span class="math inline">\(\sum\)</span> true must make <span class="math inline">\(\lnot \phi\)</span> false and make <span class="math inline">\(\phi\)</span> true.</p>
<p><strong>Resolution</strong> is a refutation system with the following influence rule.</p>
<p><span class="math inline">\(\frac{a \lor p \,\, \lnot p \land b}{a \lor b}\)</span></p>
<p>for any variable <span class="math inline">\(p\)</span> and formula <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>.</p>
<p>Consider the following as special cases</p>
<p>Unit Resolution <span class="math inline">\(\frac{a \lor p\qquad \lnot p}{a}\)</span></p>
<p>Contradiction: <span class="math inline">\(\frac{p\qquad \lnot p}{\text{Contradiction}}\)</span></p>
<h2 id="resolution">Resolution</h2>
<p>To prove <span class="math inline">\(\{p,q\}_{\text{res}} p \land q\)</span>, derive a contradiction from the assumptions <span class="math inline">\(\{p,q,\lnot(p\land q)\}\)</span></p>
<p>Conjunctive normal form</p>
<ul>
<li>A <strong>literal</strong> is a (propositional) variable or the negation of a variable</li>
<li>A <strong>clause</strong> is a disjunction of literals (cannot use and)</li>
<li>A formula is in <strong>conjunctive normal form</strong> if it is a conjunction of clauses.</li>
</ul>
<p>A formula is in CNF if and only if</p>
<ul>
<li>its only connectives are <span class="math inline">\(\lnot, \lor, \land\)</span></li>
<li><span class="math inline">\(\lnot\)</span> applies only to variables</li>
<li><span class="math inline">\(\lor\)</span> applies only to subformulas with no occurrence of <span class="math inline">\(\land\)</span>.</li>
</ul>
<p>To prove <span class="math inline">\(\phi\)</span> from <span class="math inline">\(\sum\)</span> via resolution refutation</p>
<ul>
<li>Convert each formula in <span class="math inline">\(\sum\)</span> to CNF</li>
<li>Convert <span class="math inline">\(\lnot \phi\)</span> to CNF</li>
<li>Split the CNF formulas as the <span class="math inline">\(\land\)</span>s, yielding a set of clauses</li>
<li>From the resulting set of clauses, keep applying the resolution inference rule until
<ul>
<li>The empty clause (contradiction) results (<span class="math inline">\(\phi\)</span> is a theorem)</li>
<li>The rule cannot be applied to give a new formula (<span class="math inline">\(\phi\)</span> is not a theorem)</li>
</ul></li>
</ul>
<hr />
<p>TODO: Resolution (2 classes)</p>
<h2 id="predicate-logic-first-order-logic">Predicate Logic | First Order Logic</h2>
<p>Propositional logic dealt with logical forms of compound propositions that talked about all objects in a set. Predicate logic deals with <em>some</em> object, without enumerating all objects in a set.</p>
<p>Example: Not all birds can fly</p>
<p><span class="math display">\[\lnot (\forall x \cdot (B(x) \implies F(x)))\]</span></p>
<h2 id="ingredients">Ingredients</h2>
<p>First order logic is expressed with the following ingredients</p>
<ul>
<li>A non-empty domain of objects (individuals, sets)</li>
<li>Names of individuals (also called constants)</li>
<li>Variable denoting generic objects</li>
<li>Relation (eg: equal, younger)</li>
<li>Function (eg: +, mother of)</li>
<li>Quantifiers</li>
<li>Propositional connectives</li>
</ul>
<p>A <span class="math inline">\(k\)</span>-ary relation is a set of <span class="math inline">\(k\)</span>-tuples of domain elements.</p>
<p>Example: Binary relation less-than, over a domain <span class="math inline">\(D\)</span>, is represented by the set</p>
<p><span class="math display">\[\{(x,y)\in D^2\, | \, x &lt; y \}\]</span></p>
<p><strong>Variables</strong> let us refer to an object without specifying which particular object it is.</p>
<p>In first order logic, functions may be used as arguments to another function.</p>
<p>Example: Every child is younger than its mother.</p>
<p><span class="math display">\[ \forall x \cdot \forall y \cdot ((C(x) \land M(y,x)) \implies Y(x,y))\]</span></p>
<p>But this allows <span class="math inline">\(x\)</span> to have several mothers as long as <span class="math inline">\(M(y,x)\)</span> is satisfied.</p>
<p>The above example can be rewritten as</p>
<p><span class="math display">\[\forall x \cdot (C(x) \implies Y(x,m(x)))\]</span></p>
<h2 id="syntax-1">Syntax</h2>
<p>Expressions that have a truth value are <strong>formulas</strong></p>
<p>Expressions that refer to an object of the domain are called <strong>terms</strong>.</p>
<p>An <strong>atomic formula</strong> is an expression in the form <span class="math inline">\(P(t_1,\dots,t_n)\)</span> such that <span class="math inline">\(P\)</span> is an <span class="math inline">\(n\)</span>-ary function and each <span class="math inline">\(t_i\)</span> is a term.</p>
<p><span class="math inline">\(\forall x \cdot \alpha\)</span> is a formula if <span class="math inline">\(\alpha\)</span> is a formula, and the formula <span class="math inline">\(\alpha\)</span> is the scope of the quantifier.</p>
<h2 id="interpretation">Interpretation</h2>
<p>Fix a set <span class="math inline">\(C\)</span> of constant symbols, function symbols, and relation symbols.</p>
<p>An interpretation <span class="math inline">\(M\)</span> for the set <span class="math inline">\(C\)</span> consists of</p>
<ul>
<li>A non empty set dom(<span class="math inline">\(M\)</span>), called the domain of <span class="math inline">\(M\)</span></li>
<li>For each constant <span class="math inline">\(c\)</span>, a member <span class="math inline">\(c^M\)</span> of dom(<span class="math inline">\(M\)</span>)</li>
<li>For each function symbol <span class="math inline">\(f^{(i)}\)</span>, an iary function <span class="math inline">\(f^M\)</span></li>
<li>For each relation symbol <span class="math inline">\(R^{(i)}\)</span>, an iary function relation <span class="math inline">\(R^M\)</span></li>
</ul>
<p>An interpretation is also called a <strong>model</strong>.</p>
<p>With an interpretation <span class="math inline">\(M\)</span>, for each term <span class="math inline">\(t\)</span> containing no variables, the value of <span class="math inline">\(t\)</span> under interpretation <span class="math inline">\(M\)</span>, denoted <span class="math inline">\(t^M\)</span> is</p>
<ul>
<li>If <span class="math inline">\(t\)</span> is a constant <span class="math inline">\(c\)</span>, <span class="math inline">\(t^M\)</span> is <span class="math inline">\(c^M\)</span></li>
<li>If <span class="math inline">\(t\)</span> is a function, the value <span class="math inline">\(t^M\)</span> is <span class="math inline">\(f^M(t_1^M,\dots,t_n^M\)</span></li>
</ul>
<p>The value of a term must always be a member of domain <span class="math inline">\(M\)</span></p>
<p>With an interpretation <span class="math inline">\(M\)</span>, for each formula <span class="math inline">\(\alpha\)</span> containing no variables, the value of <span class="math inline">\(\alpha\)</span> under interpretation <span class="math inline">\(M\)</span>, denoted <span class="math inline">\(\alpha^M\)</span> is</p>
<ul>
<li>If <span class="math inline">\(\alpha\)</span> is <span class="math inline">\(R(t_1,\dots,t_n)\)</span>, then <span class="math inline">\(a^M\)</span> is <span class="math inline">\(T\)</span> if <span class="math inline">\(t_1^M,\dots,t_n^M \in R^M\)</span>. Else it is <span class="math inline">\(F\)</span></li>
<li>If <span class="math inline">\(\alpha\)</span> is <span class="math inline">\(\lnot \beta\)</span> or <span class="math inline">\(\beta \star \gamma\)</span>, then <span class="math inline">\(\alpha^M\)</span> is determined the same way as for propositional logic.</li>
</ul>
<p><strong>Example:</strong> Consider an interpretation <span class="math inline">\(M\)</span> with</p>
<ul>
<li>Domain: <span class="math inline">\(N\)</span>, the natural numbers</li>
<li><span class="math inline">\(0^M\)</span>: zero</li>
<li><span class="math inline">\(f^M\)</span>: successor</li>
<li><span class="math inline">\(E^M\)</span>: is even</li>
</ul>
<p><span class="math inline">\(f(0)^M = 1\)</span>, <span class="math inline">\(E(f(0))^M = F\)</span>, <span class="math inline">\(E(f(f(0)))^M = T\)</span></p>
<p><strong>NOTE:</strong> There is NO default meaning for relation, function, or constant symbols. Functions must be defined at every point in the domain.</p>
<p>An occurrence of a variable in a formula is <strong>bound</strong> if it lies in the scope of some quantifier of the variable, otherwise it is <strong>free</strong>.</p>
<p>Example: In the formula <span class="math inline">\(P(x) \land \forall x \cdot Q(x)\)</span>, first <span class="math inline">\(x\)</span> is free and last <span class="math inline">\(x\)</span> is bound.</p>
<h2 id="substitution">Substitution</h2>
<p>The notation <span class="math inline">\(\alpha \lbrack t/x \rbrack\)</span> for a variable <span class="math inline">\(x\)</span>, term <span class="math inline">\(t\)</span>, and formula <span class="math inline">\(\alpha\)</span> denotes the formula obtained from <span class="math inline">\(\alpha\)</span> by replacing each free occurrence of <span class="math inline">\(x\)</span> with <span class="math inline">\(t\)</span></p>
<p><strong>NOTE:</strong> Substitution only affects free variables, not bound occurrences.</p>
<h2 id="semantics-1">Semantics</h2>
<p>In propositional logic, semantics was described in terms of valuations to propositional atoms. FOL includes more ingredients and the semantics must account for them too.</p>
<p>An <strong>environment</strong> is a function that assigns a value in the domain to each variable.</p>
<p><strong>Example:</strong> With domain <span class="math inline">\(N\)</span>, we might have environment <span class="math inline">\(\theta_1\)</span>, given by <span class="math inline">\(\theta_1(x) = 9\)</span> and <span class="math inline">\(\theta_1(y)=2\)</span>.</p>
<h2 id="creating-a-formula">Creating a formula</h2>
<p>To create a formula, we must specify the intepretation (includes domain, definition of symbols, and constants) and an environment that maps variables</p>
<p><strong>Example:</strong> Let <span class="math inline">\(\text{dom}\{J\}\)</span> be the collection of all words over the alphabet <span class="math inline">\(\{a,b\}\)</span></p>
<p><span class="math inline">\(0^J = a\)</span>, <span class="math inline">\(s^J\)</span> is appending <span class="math inline">\(a\)</span> to the end of the string, and <span class="math inline">\(+\)</span> is a concatenation.</p>
<p><span class="math inline">\(\theta(x) = aba\)</span></p>
<p>Evaluating <span class="math inline">\((s(s(0) + s(x)))^{(J,\theta)}\)</span> gives <span class="math inline">\(aaabaaa\)</span></p>
<h2 id="quantified-formulas">Quantified Formulas</h2>
<p>For any environment <span class="math inline">\(]theta\)</span> and domain element <span class="math inline">\(d\)</span>, the environment <span class="math inline">\(\theta\)</span> with <span class="math inline">\(x\)</span> reassigned to <span class="math inline">\(d\)</span> is denoted as <span class="math inline">\(\theta \lbrack x \rightarrow d \rbrack\)</span></p>
<p>In this case, <span class="math inline">\(x\)</span> is substituted with <span class="math inline">\(d\)</span> for every quantified occurrence.</p>
<p>Cannot directly say a statement is true for every <span class="math inline">\(x \in dom(M)\)</span>, must say <span class="math inline">\(\alpha^{(M,\lbrack x \rightarrow d \rbrack)}\)</span> for every <span class="math inline">\(d \in dom(M)\)</span></p>
<p><strong>NOTE:</strong> The values of <span class="math inline">\((\forall x \cdot \alpha)^{(M,\theta)}\)</span> and <span class="math inline">\((\exists x \cdot \alpha)^{(M,\theta)}\)</span> do not depend on the value of <span class="math inline">\(\theta(x)\)</span> as it only matters for free occurrences.</p>
<p>If <span class="math inline">\(M \vDash_\theta \alpha\)</span> for every <span class="math inline">\(\theta\)</span>, then <span class="math inline">\(M\)</span> <strong>satisfies</strong> <span class="math inline">\(\alpha\)</span>, denoted <span class="math inline">\(M \vDash \alpha\)</span></p>
<h2 id="validity-and-satisfiability">Validity and Satisfiability</h2>
<p>A first order formula can be either valid, satisfiable, and unsatisfiable. There are no tautologies in predicate logic.</p>
<p>Suppose <span class="math inline">\(\sigma\)</span> is a set of formulas and <span class="math inline">\(\alpha\)</span> is a formula. <span class="math inline">\(\alpha\)</span> is the <strong>logical consequence</strong> of <span class="math inline">\(\sigma \vDash \alpha\)</span> iff for any interpretation <span class="math inline">\(M\)</span> and environment <span class="math inline">\(\theta\)</span>, we have <span class="math inline">\(M \vDash_\theta \sigma\)</span> implies <span class="math inline">\(M \vDash_\theta \alpha\)</span></p>
<p><strong>Example</strong>: Show that <span class="math inline">\(\forall x \cdot \lnot \gamma \vDash \lnot \exists x \cdot \gamma\)</span></p>
<p><span class="math inline">\(M \vDash_\theta \forall x \cdot \lnot \gamma\)</span>. This means for every <span class="math inline">\(a \in dom(M)\)</span>, <span class="math inline">\(M \vDash_{\theta \lbrack x \rightarrow a \rbrack} \lnot \gamma\)</span></p>
<p>By definition, that means for <span class="math inline">\(a \in dom(M)\)</span>, <span class="math inline">\(M \not\vDash_{\theta \lbrack x \rightarrow a \rbrack} \gamma\)</span></p>
<p>This means there is no <span class="math inline">\(a \in dom(M)\)</span> that satisfies <span class="math inline">\(M \vDash_{\theta \lbrack x \rightarrow a \rbrack} \gamma\)</span></p>
<p>This is the RHS of the equation as required.</p>
<h2 id="proofs-in-fol">Proofs in FOL</h2>
<p><span class="math inline">\(\forall\)</span> elimination: <span class="math inline">\(\frac{\forall x \cdot \alpha}{\alpha \lbrack t / x \rbrack}\)</span></p>
<p><span class="math inline">\(\exists\)</span> introduction: <span class="math inline">\(\frac{\alpha \lbrack t/x \rbrack}{\exists x \cdot \alpha}\)</span></p>
<p>A variable is <strong>fresh</strong> in a subproof if it occurs nowhere outside the box of the subproof.</p>
<p>If you start with <span class="math inline">\(y\)</span> fresh and can conclude <span class="math inline">\(\alpha \lbrack y / x \rbrack\)</span>, you can conclude <span class="math inline">\(\forall x \cdot \alpha\)</span></p>
<p>If you start with <span class="math inline">\(\exists x \cdot a\)</span> and when you introduce <span class="math inline">\(u\)</span> fresh you can conclude <span class="math inline">\(\beta\)</span>, then you can actually conclude <span class="math inline">\(\beta\)</span></p>
<p><strong>Definition:</strong> First Order Logic with Equality is First-Order Logic with the restriction that the symbol <code>=</code> must be interpreted as equality on the domain</p>
<p><span class="math display">\[(=)^L = \{(d,d) | d \in dom(L)\}\]</span></p>
<p>If <span class="math inline">\(t = t\)</span>, you can do an equals introduction</p>
<p>If <span class="math inline">\(t_1 = t_2\)</span> and <span class="math inline">\(\alpha \lbrack t_1 / x \rbrack\)</span> then you can conclude <span class="math inline">\(\alpha \lbrack t_2 /x \rbrack\)</span></p>
<p>An <strong>axiom</strong> is a premise that is always taken, it need not be listed explicitly.</p>
<p>EQ1: <span class="math inline">\(\forall x \cdot x = x\)</span> is n axiom.</p>
<p>EQ2: For each formula <span class="math inline">\(\alpha\)</span> and variable <span class="math inline">\(z\)</span></p>
<p><span class="math inline">\(\forall x \cdot \forall y \cdot (x = y \implies (\alpha \lbrack x / z \rbrack \implies \alpha \lbrack y / z \rbrack))\)</span></p>
<p>These axioms then imply symmetry and transitivity.</p>
<h2 id="arithmetic-data-structures-and-programs">Arithmetic, Data Structures, and Programs</h2>
<hr />
<h2 id="relations-on-lists">Relations on Lists</h2>
<p>If <span class="math inline">\(x\)</span> is the empty list</p>
<p><span class="math inline">\(\forall x \cdot \forall y \cdot (x = e) \implies \lnot \text{ First}(x,y)\)</span></p>
<p><span class="math inline">\(\forall y \cdot \lnot \text { First}(x,y)\)</span></p>
<p><span class="math inline">\(x\)</span> is not the empty list</p>
<p><span class="math inline">\(\forall x \cdot \forall y \cdot x \neq e \implies x = cons(y,z)\)</span></p>
<p><span class="math inline">\(\forall y \cdot \forall z \cdot \text {First}(cons(y,z),y)\)</span></p>
<h2 id="append">Append</h2>
<p><span class="math inline">\(\text{Append}(x,y,z)\)</span> represents appending <span class="math inline">\(x\)</span> to <span class="math inline">\(y\)</span> and getting <span class="math inline">\(z\)</span></p>
<p>How do we write this definition in logic?</p>
<p>Case 1: <span class="math inline">\(x\)</span> is the empty list.</p>
<p><span class="math inline">\(\forall x \cdot \forall y \cdot (x = e \implies \text{ Append}(x,y,y))\)</span></p>
<p><span class="math inline">\(\forall y \cdot \text{ Append}(e,y,y)\)</span></p>
<p>Case 2: <span class="math inline">\(x\)</span> is not the empty list</p>
<p><span class="math inline">\(R_{first} (x,v_f) \implies\)</span></p>
<p><span class="math inline">\(\qquad R_{rest}(x,v_r) \implies\)</span></p>
<p><span class="math inline">\(\qquad\qquad \text{Append}(v_r,y,v_a) \implies\)</span></p>
<p><span class="math inline">\(\qquad \qquad \qquad \text{Append}(x,y,cons(v_f,v_a))\)</span></p>
<p>Using this simplification</p>
<p><span class="math inline">\(a \implies b \implies c \implies d \equiv (a \land b \land c) \implies d\)</span></p>
<p>The above statement may be simplified.</p>
<p><span class="math inline">\(x \neq e \implies (R_{first} (x,v_f) \land R_{rest}(x,v_r) \land \text{Append}(v_r,y,v_a) \implies \text{Append}(x,y,cons(v_f,v_a))\)</span></p>
<p><span class="math display">\[\forall x \cdot \forall v_f \cdot \forall v_r \cdot \forall y \cdot \forall v_a \cdot (x \neq e \implies (R_{first} (x,v_f) \land R_{rest}(x,v_r) \land \text{Append}(v_r,y,v_a) \implies \text{Append}(x,y,cons(v_f,v_a)))\]</span></p>
<p>Simplified using BL1 and BL2</p>
<p><span class="math inline">\(\forall v_r \cdot \forall y \cdot \forall v_a \cdot \forall v_f \cdot (\text{Append}(v_r,y,v_a) \implies \text{ Append}(cons(v_f,v_r),y,cons(v_f,v_a)))\)</span></p>
<p><span class="math inline">\(\forall x \cdot \forall y \cdot \forall z \cdot \forall w \cdot (\text{Append}(x,y,z) \implies \text{ Append}(cons(w,x),y,cons(w,z)))\)</span></p>
<p><strong>Example:</strong> <span class="math inline">\(\text{Append}(x,y)\)</span> is true iff <span class="math inline">\(x\)</span> is a member of <span class="math inline">\(y\)</span></p>
<p>Case 1: Empty lists. <span class="math inline">\(\forall x \cdot \lnot \text{ Member}(x,e)\)</span></p>
<p>Case 2: <span class="math inline">\(\forall x \cdot \forall z \cdot (\text{Member}(x,cons(x,z)))\)</span></p>
<p><span class="math inline">\(\forall x \cdot \forall w \cdot \forall z \cdot (\text{Member}(x,z) \iff \text{Member}(x,cons(w,z)))\)</span></p>
<p><strong>Example:</strong> Prove Member<span class="math inline">\((b, &lt;a,b,c&gt;)\)</span></p>
<p>Member<span class="math inline">\((b,cons(a, cons(b, cons(c, e))))\)</span></p>
<p>Member<span class="math inline">\((b, cons(b, cons(c, e)))\)</span></p>
<p>True</p>
<p><strong>Example:</strong> <span class="math inline">\(\lnot\)</span>Member<span class="math inline">\((b,&lt;a&gt;)\)</span></p>
<p><strong>Idea:</strong> Start with assuming Member<span class="math inline">\((b,&lt;a&gt;)\)</span> and reach a contradiction. Therefore assumption is false and can conclude <span class="math inline">\(\lnot\)</span>Member<span class="math inline">\((b,&lt;a&gt;)\)</span></p>
<p><strong>Example:</strong> Reverse<span class="math inline">\((x,y)\)</span> is true iff <span class="math inline">\(y\)</span> is the reverse of list <span class="math inline">\(x\)</span>.</p>
<p>Case 1: Reverse<span class="math inline">\((e,e)\)</span> is true. <span class="math inline">\(\forall x \cdot (x \neq e \implies \lnot\)</span>Reverse<span class="math inline">\((x,e) \land \lnot\)</span>Reverse<span class="math inline">\((e,x))\)</span></p>
<p>Case 2: Reverse of a list is the reverse of the rest of the list appended onto the first element.</p>
<p><span class="math inline">\(\forall w \cdot \forall x \cdot \forall y \cdot \forall z \cdot (\)</span>Reverse<span class="math inline">\((x,y) \land\)</span> Append<span class="math inline">\((y,cons(w,e),z)) \implies\)</span> Reverse<span class="math inline">\((cons,w,x),z)))\)</span></p>
<p>Reverse<span class="math inline">\((cons(b,e),cons(b,e))\)</span></p>
<hr />
<p>Given terms <span class="math inline">\(t_1, t_2\)</span>, determine whether there are substitutions for the variables that make the terms the same. Finding such substitution is called <strong>unification</strong> of the terms.</p>
</body>
</html>
