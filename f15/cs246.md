# CS 246

A **shell** is an interface to a computer.

A graphical shell usually includes mouse inputs and fancy graphical interfaces.

A command shell is one where commands are entered to execute programs.

## Linux shell

Linux files are either directories or regular files. Windows only has folders and files.

Backticks execute commands within double quotes (not single)


Eg: `echo "Today is \`date\`"`

Eg: `echo "Today is $(date)"`

`egrep` is the extended version of `grep.` Equivalent to `grep -e`

`[abc]` match a single character within box

`[^abc]` not match any of the characters

`?` matches 0 or 1 of preceding expression. Optional argument

`*` is 0 or more of preceding

`+` is one or more of preceding

`.` is any one character

`^` is start of line

`$` is end of line

[0-9], [a-z] etc

Special symbols lose meaning in square brackets. No need to escape

## chmod
u=user
g=group
o=other
a=all

Example:

Only read write permission for everyone

`chmod a=rw file`

Remove execute permission from everyone

`chmod a-x file`

## Variables

`x=1`
`echo ${x}`

Double quotes allow expansion variables while single quotes do not

## Shell script

A script is a text file that contains a sequence of Linux commands, executed as a program.

Start with `$!/bin/bash`

Execute with `./file`

Don't forget to chmod execute permissions.

## Arguments to a script

Access arguments within a script with `$1,$2,$3` etc.

If an argument is not provided, it will be the empty string

```bash
#!/bin/bash
egrep "^${1}$" /usr/share/dict/words > /dev/null # This throws away the output
usage(){
    echo "Usage $0 password"
    exit 1
}
if [ ${#} -ne 1 ]; then
    usage
fi
if [ $? -eq 0 ]; then
    echo 'yes'
else
    echo 'no'
fi
```

In Linux $0$ represents success, anything else represents failure.

Status code can be obtained by `$?`

The square command is used for comparison.

`[ 1 -eq 1]` This doesn't provide any output
`echo $?` Must use status code to determine truth value.

`$#` gives the number of arguments provided to the script.

`$0` is the name of a script.

`exit 1` terminates the program and returns a status code of 1 (failure).

`lt` is less than. `le` is less than equal.

By default, if no status code is returned, it is assumed to be 0 (success).

Print numbers from $1$ to `$1`
```bash
#!/bin/bash
x=1

while [ $x -le $1 ]; do
    echo ${x}
    x=$((x+1))
done
```

Mathematical operations are done with `$((1+1))`, operation surrounded by two brackets. Else it will just concatenate two strings.

## For loops

Rename all .c files to .cc.

```bash
filename=hello.C
mv hello.c ${filename%C}.cc
```

Another way is

```bash
for name in *.C; do
    mv ${name} ${name%C}.cc
done
```

`{filename#abc}`

**Example:** How many times does the word \$1 appear in the file \$2.

```bash
count=0
for word in `cat $2`; do
    if [ $word = "$1" ]; then
        count=$((count+1))
    fi
done
echo $count
```
To get the last Friday of the month, where `$1` and `$2` represent month and year.

`cal $1 $2 |  '{print }' | egrep "[0-9]" | tail -1`

# C++

C++ was originally called C with classes.

Hello World!!!

```cpp
# include <iostream>
using namespace std; // Don't need to write std::cout
int main() {
    cout << "Hello World" << endl;
    return 0;
}
```

`g++ hello.cc -o executable.out`

C++ has three stream variables.

`cout` to output to standard output
`cin` to get input from standard input
`cerr` to output to standard error

Input Operator: `>>`

Output Operator: `<<`


```cpp
int x,y;
cin >> x >> y; //Reads in two variables
```
Whitespace is ignored when reading.

<C-d> sends an EOF signal, the read fails, program continues.

Once a read fails (bad input), all subsequent reads fail

If a read fails, `cin.fail()` is true.

If a read fails due to EOF, `cin.fail()` and `cin.eof()` are both true

If you add an int to a double, int is converted to double

There is an implicit conversion from `cin` to `void *`

`cin` is automatically true if `!cin.fail()`
