# CS 246

A **shell** is an interface to a computer.

A graphical shell usually includes mouse inputs and fancy graphical interfaces.

A command shell is one where commands are entered to execute programs.

## Linux shell

Linux files are either directories or regular files. Windows only has folders and files.

Backticks execute commands within double quotes (not single)


Eg: `echo "Today is \`date\`"`

Eg: `echo "Today is $(date)"`

`egrep` is the extended version of `grep.` Equivalent to `grep -e`

`[abc]` match a single character within box

`[^abc]` not match any of the characters

`?` matches 0 or 1 of preceding expression. Optional argument

`*` is 0 or more of preceding

`+` is one or more of preceding

`.` is any one character

`^` is start of line

`$` is end of line

[0-9], [a-z] etc

Special symbols lose meaning in square brackets. No need to escape

## chmod
u=user
g=group
o=other
a=all

Example:

Only read write permission for everyone

`chmod a=rw file`

Remove execute permission from everyone

`chmod a-x file`

## Variables

`x=1`
`echo ${x}`

Double quotes allow expansion variables while single quotes do not

## Shell script

A script is a text file that contains a sequence of Linux commands, executed as a program.

Start with `$!/bin/bash`

Execute with `./file`

Don't forget to chmod execute permissions.

## Arguments to a script

Access arguments within a script with `$1,$2,$3` etc.

If an argument is not provided, it will be the empty string

```bash
#!/bin/bash
egrep "^${1}$" /usr/share/dict/words > /dev/null # This throws away the output
usage(){
    echo "Usage $0 password"
    exit 1
}
if [ ${#} -ne 1 ]; then
    usage
fi
if [ $? -eq 0 ]; then
    echo 'yes'
else
    echo 'no'
fi
```

In Linux $0$ represents success, anything else represents failure.

Status code can be obtained by `$?`

The square command is used for comparison.

`[ 1 -eq 1]` This doesn't provide any output
`echo $?` Must use status code to determine truth value.

`$#` gives the number of arguments provided to the script.

`$0` is the name of a script.

`$@` lists all the arguments

`exit 1` terminates the program and returns a status code of 1 (failure).

`lt` is less than. `le` is less than equal.

By default, if no status code is returned, it is assumed to be 0 (success).

Print numbers from $1$ to `$1`
```bash
#!/bin/bash
x=1

while [ $x -le $1 ]; do
    echo ${x}
    x=$((x+1))
done
```

Mathematical operations are done with `$((1+1))`, operation surrounded by two brackets. Else it will just concatenate two strings.

## For loops

Rename all .c files to .cc.

```bash
filename=hello.C
mv hello.c ${filename%C}.cc
```

Another way is

```bash
for name in *.C; do
    mv ${name} ${name%C}.cc
done
```

`{filename#abc}`

**Example:** How many times does the word \$1 appear in the file \$2.

```bash
count=0
for word in `cat $2`; do
    if [ $word = "$1" ]; then
        count=$((count+1))
    fi
done
echo $count
```

To get the last Friday of the month, where `$1` and `$2` represent month and year.

`cal $1 $2 |  '{print }' | egrep "[0-9]" | tail -1`

# C++

C++ was originally called C with classes.

Hello World!!!

```cpp
# include <iostream>
using namespace std; // Don't need to write std::cout
int main() {
    cout << "Hello World" << endl;
    return 0;
}
```

`g++ hello.cc -o executable.out`

C++ has three stream variables.

`cout` to output to standard output
`cin` to get input from standard input
`cerr` to output to standard error

Input Operator: `>>`

Output Operator: `<<`


```cpp
int x,y;
cin >> x >> y; //Reads in two variables
```

Whitespace is ignored when reading.

<C-d> sends an EOF signal, the read fails, program continues.

Once a read fails (bad input), all subsequent reads fail

If a read fails, `cin.fail()` is true.

If a read fails due to EOF, `cin.fail()` and `cin.eof()` are both true

If you add an int to a double, int is converted to double

There is an implicit conversion from `cin` to `void *`

`cin` is automatically true if `!cin.fail()`

`a >> b` is a binary shift operation

Example: `21 >> 3` is `10101` right shifted $3$ times, resulting in `10`

Operating overloading: `21 >> 3` and `cin >> a`

Same operator has different meaning depending on the types of the operands

The input operator evaluates to an istream (cin)

```cpp
int main() {
    int i;
    while (cin >> i) {
        cout << i << endl;
    }
}
```

### Cascading

`cout << i << endl;`

`cout << endl;`

`cout;`

### Dealing with bad input

`cin.clean()` acknowledges that a read failed. It lowers the fail flag.

`cin.ignore()` discards whatever is at the front of the input stream. Discards everything until it hits whitespace

`cin.ignore()` discards only one character actually. TODO!

## Strings

```cpp
#include <String>

int main () {
    string s;
    cin >> s;
    cout << s;
}
```

`getline(cin,s)` will start reading from first non whitespace character until newline character

**IO Manipulators** are used to format output

`cout << hex << x` changes all subsequent couts to hexadecimal. To revert back to decimal, simply use `cout << dec`

`cout << boolalpha` changes boolean numbers to true and false

The stream abstraction can be used with other data sources. To read/write to files, include `<fstream>`, which is split into `ifstream` input file stream and  `ofstream` output file stream


```cpp
# include <iostream>
# include <fstream>

int main() {
    ifstream file("suite.txt");
    string s;
    while (file >> s) {
        cout << s << endl;
    }
}
```

`file` is a stack-allocated variable. Memory is reclaimed when stack is popped.

We can treat a string as a stream. `# include <ssstream>`

istringstream to read from a string and ostringstream to write to a string.

```cpp
int main(){
    ostringstream ss;
    int lo = 1, hi = 100;
    ss << "Enter a number between " << lo " and " << hi;
    string s = ss.str();
    cout << s << endl;
}
```

**Note:** To read integer input, first read as string, and using istringstream as input and read into integer. It avoids cleaning and ignoring input resulting in much cleaner code.

```cpp
int main () {
  string s;
  while (cin >> s) {
    istringstream ss(s);
    int n;
    if (ss >> n) cout << n << endl;
  }
}
```

Beautiful code XD

## Strings

In C, strings are an array of characters with a null terminator. C++ has a string type. Automatic resizing is much safer because no change of overwriting null terminator.
`string str = "hello"` is represented as an array of characters.

Conversions from C style strings to C++ strings.

C: `strcmp`, C++: `s1 == s2`, `s1 != s2`, `>`, `<`

C: `strlen`, C++: `str.length()`

C: `strcat(s1,s2)`, C++: `s1+s2`

In C++, can use `s[1]` to access characters in a string.

## Default Arguments

**Aside:**

```c++
void print(string filename) {
    string s;
    ifstream file(filename); // Assumes filename is a C style string.
    while (file >> s) {
        ... // Doesn't work
    }
}
```

Working version

```c++
void print(string filename) {
    string s;
    ifstream file(filename.c_str()); // Works!
    while (file >> s) {
        ...
    }
}
```

A parameter that has a default value must be followed only by parameters which have default values.

In C, there is no function overloading. Valid in C++ though. (must still be different number of or type of arguments)

Two functions cannot just differ on their return type

Cannot do `void test()` and `void test(int i=0)` for method overloading.

## Operator Overloading

Operators are implemented as functions.

`-21 >> 3` is equivalent to `operator>>(21,3)`

## Declaration Before Use

Must declare something before using.

**Problem:** Mutual recursion.

**Solution:** Forward declaration. Declare first, then define later. In declaration, don't need to declare variable name. Just type is enough.

## Array

Built in construct to store collections. Located in a continuous block of memory.

The name of the array is the same as the address of the first element of the array. `a == &a[0]`


## Structures

C:
```c
struct Node {
    int data;
    struct Node * next;
};

struct Node n1 = {3,0};
```

C++
```cpp
struct Node {
    int data;
    Node *next;
}

Node n2 = {3,0};
```

## Constants

**NOTE:** A constant definition must be initialized.

```cpp
int n = 5;
consta int * p = &n;
p = &m; //valid
*p = 10; // INVALID, the integer is a constant
n = 19; // Valid
```

## Pass by Reference

`cin >> x`

In C++, `x` is pass by reference, which is why it can be modified by the operator function.

```cpp
int y = 10;
int &z = y; // z is a reference to y (constant pointer)

// Similar to
int * const z = &y;
```

A reference acts as a constant pointer with automatic dereferencing.

z is both another name and an alias for y.

`int * p = & z` creates a pointer to y.

A reference must be initialized with a value that has an address.

```cpp
int &x = 5; // Invalid
int &x = y + y; // Invalid
```

An lvalue is anything that is a storage location

#### Other fun stuff

- Cannot create pointer or reference to another reference.
- Cannot create array of references
- Can create a reference to a pointer
- Can use references as parameters!

```cpp
void inc(int &n) { // Changes to pass by reference
    n+=1;
}

int main() {
    int x = 5;
    inc(x);
    cout << x; // Incremented because of pass by reference instead of value
}
```

To prevent a function from changing a variable, we can use a const reference. Cannot use the reference to change the original variable. :D

```cpp
void bar (const ReallyBig & rb) {
    //...
}
```

```cpp
void f(int &n) {}
void g(const int *n) {}
f(5) // Illegal
f(y+y) // Illegal

g(5) // Legal
g(y+y) // Yes
```

This is because g does not have permission to change n, so compiler will allow you to pass a reference to an unknown.

Try to always consider passing by cost reference for anything larger than an int (4 bytes).

## Dynamic Memory

Always use the stack unless

- Value must persist beyond variable scope
- Size of collection is unknown or subject to resizing
- Large memory allocation

In C++, we use new and delete for memory allocation. (Type aware, safer to use)

```cpp
Node n; // Stack
Node * p = new Node; // Heap

delete p; // p must be a heap allocated pointer
```

No need to tell `new` how much space is needed

Calling delete on null is fine.

### Arrays

```cpp
int * p = new int[num];

delete [] p; // Don't forget the [] to delete the array
```

A **dangling pointer** is a pointer to memory that is not in use.

## Operator Overloading

In C, when we wanted to add structs, we had to define our own function to do so. For example `Vec v3 = add(Vec v1, Vec v2)`

What if we want to do `Vec v3 = v1 + v2`? The `+` operator may be overloaded.

```cpp
Vec operator+(const Vec &v1, const Vec &v2) {
    Vec v;
    v.x = v1.x + v2.x;
    v.y = v1.y + v2.y;
    return v;
}
```

Need const for cascading. The return value is not an lvalue, but it will still work if const is specified.

```cpp
Vec operator*(const int k, const Vec &v1) {
    Vec v;
    v.x = k * v1.x;
    v.y = k * v1.y;
    return v;
}

Vec operator*(const Vec &v1, const int k) {
    return k & v1;
}
```

Example:

```cpp
struct Grade {
    string name;
    int grade;
};
```

What if we want to do `cout << grade`?

```cpp
ostream & operator<<(ostream &out, const Grade &g) {
    out << "Student: " << g.name << endl;
    out << "Grade: " << g.grae << "%";
    return out;
}
```

Another Example:

```cpp
istream & operator>>(istream &in, Grade &g) {
    in >> g.name;
    in >> g.grade;
    if (g.grade > 100) g.grade = 100;
    return in;
}
```

## Preprocessor

`# include` is a preprocessor directive. Copies the actual file.

`g++ -E file.cc` stop at preprocessor output

`g++ -E -P file.cc` stop at preprocessor output and omits line numbers

`# define VAR VALUE` creates a search and replace for VAR and replaces with VALUE. (Previously used for constants).

Preprocessor does not need to know C++

## Conditional Computation

Native windows applications needed `int winMain()` instead of `int main()`.

Can use a preprocessor if statement to check and follow operating system guidelines

```cpp
#define Unix 1
#define Windows 2

#define OS Unix

#if OS == Unix
int main(){
#elif OS == Windows
int winMain() {
#endif
    //code
}
```

Must manually change defines. Alternative: Use `g++` with arguments

`g++ -DOS=Unix`

In this case, don't need to define OS anymore. Everything else remains the same.

`#ifdef VAR` is true if var is defined

`#ifndef VAR` is true if var is not defined

Don't forget `#endif`

```cpp

int main(){
#ifdef DEBUG
    cout << some_debug_var << endl;
#endif
    // other stuff
}
```

## Separate Compilation

Files are split into two categories: Interface files, implementation file

Compiling multiple files

`g++ file.cc` (requires that all cc file are part of the program)

Never compile a header file.

Separate compilation involves compiling individual cc files separating and then merging them to create the executable.

`g++` compiles, links, and produces an executable. Cannot compile individual files because linker will fail

To just compile, use `g++ -c` to avoid linker problems. This compiles into a `.o` file

Object file contains compiled code, what implementations are needed and defined.

To link, `g++ main.o vector.o`

## Dealing with Global Variables

Define the global variable in a header fie. Define it in a .cc file. Or else there will be two of the same variable and compiler will cause error.

`extern int global`

Avoiding multiple definitions of types (multiple include statements on the same file):

```cpp
# ifndef HEAD_H // common convention is FILENAME_H
# define HEAD_H

struct blah {
    // definition
}
# endif
```

This is known as an include guard.

